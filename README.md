### Neograph: Reference-guided transcriptome assembly

Neograph is both a command-line tool for generation of a gene model given a set of aligned RNA-seq reads, and an API for development of identification/quantification of transcripts from a splice graph data structure.

Neograph uses no underlying assumptions (such as parsimony) to refine the number of possible transcripts that can explain your data. It relies purely on evidence of exon-exon junctions from split-mapped reads, canonical transcription start sites, and regions identified as "coverage islands", to generate a splice graph such as the one below. It then uses depth-first search to generate all possible paths (transcripts) in the graph. For details on how Neograph works, please visit the wiki page.

![Alt text](splicegraph.png?raw=true "Splice graph")

The primary intended application of Neograph is **novel splice variant detection.** While Neograph uses TSSs from only the provided annotation to maximize accuracy (*de novo* TSS detection is not reliable), it can identify alternative last exons (ALEs).

Neograph is NOT for:
* Gene discovery
* Expression quantification

#### Dependencies
* Python 2.7x
* pysam 0.9.1.4
* samtools 1.3.1

#### Getting started

Before you begin, make sure to have a reliable reference annotation in GTF format such as RefSeq, and an indexed RNA-seq alignment BAM file generated by a splice-aware aligner such as TopHat.

If you are interested in protein coding genes, please make sure your reference annotation includes 'start_codon' lines (Ensembl and RefSeq include these by default). Neograph uses this info to output the correct start codon positions for each isoform.

**To use as a command-line tool:**

```bash
python neograph.py --gtf path/to/reference/annotation --bam path/to/aligned/RNAseq/reads > [output.gtf]
```

To get info on additional parameters:

```bash
python neograph.py --help
```

**Basic API usage:**

```python
>>> import neograph as ng
```
Read in your BAM and GTF files:
```python
>>> genes, bam = ng.readInput('/path/to/ref/annotation','path/to/BAM/file')
```
Make a neograph Gene object for your gene of interest (or iterate through the entire "genes" dictionary)
```python
>>> myGene = ng.makeGene('geneID',genes,bam)
```
Generate all possible paths for your gene:
```python
>>> myGene.getPaths()
>>> paths = myGene.paths
```
Retrieve splice graph:
```python
>>> spliceGraph = myGene.spliceGraph
```
The splice graph follows a {exon: set([neighboring exons])} data structure. You may also want information on coverage of junctions between these exons (representative of "edge weights" in the graph).
```python
>>> edgeWeights = myGene.junctionDict
```
More detailed documentation and performance benchmarks coming soon!
